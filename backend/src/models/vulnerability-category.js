var mongoose = require('mongoose');
var Schema = mongoose.Schema;

var Field = {
    _id:    false,
    label:  String,
    fieldType:   {type: String, enum: ['input', 'text']}
}

var VulnerabilityCategorySchema = new Schema({
    name:   {type: String, unique: true},
    fields: [Field]
}, {timestamps: true});

/*
*** Statics ***
*/

// Get all vulnerabilityCategorys
VulnerabilityCategorySchema.statics.getAll = () => {
    return new Promise((resolve, reject) => {
        var query = VulnerabilityCategory.find();
        query.select('name fields')
        query.exec()
        .then((rows) => {
            resolve(rows);
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Create vulnerabilityCategory
VulnerabilityCategorySchema.statics.create = (vulnerabilityCategory) => {
    return new Promise((resolve, reject) => {
        var uniqueArray = Array.from(new Set(vulnerabilityCategory.fields.map(e => e.label)))
        .map(label => {return vulnerabilityCategory.fields.find(e => e.label === label)})
        if (uniqueArray.length !== vulnerabilityCategory.fields.length)
            throw({fn: 'BadParameters', message: 'Vulnerability category fields contain duplicate label values'})
        var query = new VulnerabilityCategory(vulnerabilityCategory);
        query.save()
        .then((row) => {
                resolve(row);
        })
        .catch((err) => {
            if (err.code === 11000)
                reject({fn: 'BadParameters', message: 'Vulnerability Category name already exists'});
            else
                reject(err);
        })
    })
}

// Update vulnerabilityCategory
VulnerabilityCategorySchema.statics.update = (name, vulnerabilityCategory) => {
    return new Promise((resolve, reject) => {
        var uniqueArray = Array.from(new Set(vulnerabilityCategory.fields.map(e => e.label)))
        .map(label => {return vulnerabilityCategory.fields.find(e => e.label === label)})
        if (uniqueArray.length !== vulnerabilityCategory.fields.length)
            throw({fn: 'BadParameters', message: 'Vulnerability category fields contain duplicate label values'})
        var query = VulnerabilityCategory.findOneAndUpdate({name: name}, vulnerabilityCategory)
        query.exec()
        .then((row) => {
            if (row)
                resolve(row)
            else
                reject({fn: 'NotFound', message: 'Vulnerability category not found'})
        })
        .catch((err) => {
            if (err.code === 11000)
                reject({fn: 'BadParameters', message: 'Vulnerability Category already exists'});
            else
                reject(err);
        })
    })
}

// Update vulnerability Categories
VulnerabilityCategorySchema.statics.updateAll = (vulnCategories) => {
    return new Promise((resolve, reject) => {
        for (var i=0; i<vulnCategories.length; i++) {
            var uniqueArray = Array.from(new Set(vulnCategories[i].fields.map(e => e.label)))
            .map(label => {return vulnCategories[i].fields.find(e => e.label === label)})
            if (uniqueArray.length !== vulnCategories[i].fields.length)
                throw({fn: 'BadParameters', message: 'Vulnerability category fields contain duplicate label values'})
        }
        VulnerabilityCategory.deleteMany()
        .then((row) => {
            VulnerabilityCategory.insertMany(vulnCategories)
        })
        .then((row) => {
            resolve("Vulnerability Categories updated successfully")
        })
        .catch((err) => {
            reject(err);
        })
    })
}

// Delete vulnerabilityCategory
VulnerabilityCategorySchema.statics.delete = (name) => {
    return new Promise((resolve, reject) => {
        VulnerabilityCategory.deleteOne({name: name})
        .then((res) => {
            if (res.deletedCount === 1)
                resolve('Vulnerability Category deleted');
            else
                reject({fn: 'NotFound', message: 'Vulnerability Category not found'});
        })
        .catch((err) => {
            reject(err);
        })
    });
}

/*
*** Methods ***
*/

var VulnerabilityCategory = mongoose.model('VulnerabilityCategory', VulnerabilityCategorySchema);
module.exports = VulnerabilityCategory;