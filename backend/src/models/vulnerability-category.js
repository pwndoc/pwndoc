var mongoose = require("mongoose");
var Schema = mongoose.Schema;

var Field = {
  _id: false,
  label: String,
  fieldType: { type: String, enum: ["input", "text"] },
};

var VulnerabilityCategorySchema = new Schema(
  {
    name: { type: String, unique: true },
    description: String,
    fields: [Field],
  },
  { timestamps: true }
);

/*
 *** Statics ***
 */

// Get all vulnerabilityCategorys
VulnerabilityCategorySchema.statics.getAll = () => {
  return new Promise((resolve, reject) => {
    var query = VulnerabilityCategory.find();
    query.select("name description fields");
    query
      .exec()
      .then((rows) => {
        resolve(rows);
      })
      .catch((err) => {
        reject(err);
      });
  });
};

// Get by ID
VulnerabilityCategorySchema.statics.getByName = (name) => {
  return new Promise((resolve, reject) => {
    var query = VulnerabilityCategory.findOne({ name });
    query.select("name description fields");
    query
      .exec()
      .then((rows) => {
        resolve(rows);
      })
      .catch((err) => {
        reject(err);
      });
  });
};

// Create vulnerabilityCategory
VulnerabilityCategorySchema.statics.create = (vulnerabilityCategory) => {
  return new Promise((resolve, reject) => {
    var uniqueArray = Array.from(
      new Set(vulnerabilityCategory.fields.map((e) => e.label))
    ).map((label) => {
      return vulnerabilityCategory.fields.find((e) => e.label === label);
    });
    if (uniqueArray.length !== vulnerabilityCategory.fields.length)
      throw {
        fn: "BadParameters",
        message: "Vulnerability category fields contain duplicate label values",
      };
    var query = new VulnerabilityCategory(vulnerabilityCategory);
    query
      .save()
      .then((row) => {
        resolve(row);
      })
      .catch((err) => {
        if (err.code === 11000)
          reject({
            fn: "BadParameters",
            message: "Vulnerability Category name already exists",
          });
        else reject(err);
      });
  });
};

// Update vulnerabilityCategory
VulnerabilityCategorySchema.statics.update = (
  name,
  description,
  vulnerabilityCategory
) => {
  return new Promise((resolve, reject) => {
    var uniqueArray = Array.from(
      new Set(vulnerabilityCategory.fields.map((e) => e.label))
    ).map((label) => {
      return vulnerabilityCategory.fields.find((e) => e.label === label);
    });
    if (uniqueArray.length !== vulnerabilityCategory.fields.length)
      throw {
        fn: "BadParameters",
        message: "Vulnerability category fields contain duplicate label values",
      };
    var query = VulnerabilityCategory.findOneAndUpdate(
      { name: name, description: description },
      vulnerabilityCategory
    );
    query
      .exec()
      .then((row) => {
        if (row) resolve(row);
        else
          reject({
            fn: "NotFound",
            message: "Vulnerability category not found",
          });
      })
      .catch((err) => {
        if (err.code === 11000)
          reject({
            fn: "BadParameters",
            message: "Vulnerability Category already exists",
          });
        else reject(err);
      });
  });
};

// Update vulnerability Categories
VulnerabilityCategorySchema.statics.updateAll = (vulnCategories) => {
  return new Promise((resolve, reject) => {
    for (var i = 0; i < vulnCategories.length; i++) {
      var uniqueArray = Array.from(
        new Set(vulnCategories[i].fields.map((e) => e.label))
      ).map((label) => {
        return vulnCategories[i].fields.find((e) => e.label === label);
      });
      if (uniqueArray.length !== vulnCategories[i].fields.length)
        throw {
          fn: "BadParameters",
          message:
            "Vulnerability category fields contain duplicate label values",
        };
    }
    VulnerabilityCategory.deleteMany()
      .then((row) => {
        VulnerabilityCategory.insertMany(vulnCategories);
      })
      .then((row) => {
        resolve("Vulnerability Categories updated successfully");
      })
      .catch((err) => {
        reject(err);
      });
  });
};

// Delete vulnerabilityCategory
VulnerabilityCategorySchema.statics.delete = (name) => {
  return new Promise((resolve, reject) => {
    VulnerabilityCategory.deleteOne({ name: name })
      .then((res) => {
        if (res.deletedCount === 1) resolve("Vulnerability Category deleted");
        else
          reject({
            fn: "NotFound",
            message: "Vulnerability Category not found",
          });
      })
      .catch((err) => {
        reject(err);
      });
  });
};

/*
 *** Methods ***
 */

var VulnerabilityCategory = mongoose.model(
  "VulnerabilityCategory",
  VulnerabilityCategorySchema
);
module.exports = VulnerabilityCategory;
