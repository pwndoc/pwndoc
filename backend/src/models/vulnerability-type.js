var mongoose = require('mongoose');
var Schema = mongoose.Schema;

var VulnerabilityTypeSchema = new Schema({
    name:   String,
    locale: String,
    order:  Number
}, {timestamps: true});

VulnerabilityTypeSchema.index({"name": 1, "locale": 1}, {name: "unique_name_locale", unique: true})

/*
*** Statics ***
*/

// Get all vulnerabilityTypes
VulnerabilityTypeSchema.statics.getAll = () => {
    return new Promise((resolve, reject) => {
        var query = VulnerabilityType.find().sort({order: 1});
        query.select('-_id name locale')
        query.exec()
        .then((rows) => {
            resolve(rows);
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Create vulnerabilityType
VulnerabilityTypeSchema.statics.create = (vulnerabilityType) => {
    return new Promise(async (resolve, reject) => {
        const lastDocument = await VulnerabilityType.findOne({}, {}, { sort: { order: -1 } });
        const newOrder = lastDocument ? lastDocument.order + 1 : 1;
        vulnerabilityType.order = newOrder;
        var query = new VulnerabilityType(vulnerabilityType);
        query.save()
        .then((row) => {
                resolve(row);
        })
        .catch((err) => {
            if (err.code === 11000)
                reject({fn: 'BadParameters', message: 'Vulnerability Type already exists'});
            else
                reject(err);
        })
    })
}

// Update vulnerability Types
VulnerabilityTypeSchema.statics.updateAll = (vulnerabilityTypes) => {
    return new Promise((resolve, reject) => {
        VulnerabilityType.deleteMany()
        .then((row) => {
            let order = 1
            vulnerabilityTypes.forEach(type => {
                type.order = order
                order += 1
            })
            VulnerabilityType.insertMany(vulnerabilityTypes)
        })
        .then((row) => {
            resolve("Vulnerability Types updated successfully")
        })
        .catch((err) => {
            reject(err);
        })
    })
}

// Delete vulnerabilityType
VulnerabilityTypeSchema.statics.delete = (name) => {
    return new Promise((resolve, reject) => {
        VulnerabilityType.deleteOne({name: name})
        .then((res) => {
            if (res.deletedCount === 1)
                resolve('Vulnerability Type deleted');
            else
                reject({fn: 'NotFound', message: 'Vulnerability Type not found'});
        })
        .catch((err) => {
            reject(err);
        })
    });
}

VulnerabilityTypeSchema.statics.backup = (path) => {
    return new Promise(async (resolve, reject) => {
        const fs = require('fs')

        function exportVulnTypesPromise() {
            return new Promise((resolve, reject) => {
                const writeStream = fs.createWriteStream(`${path}/vulnerabilityTypes.json`)
                writeStream.write('[')

                let vulnTypes = VulnerabilityType.find().cursor()
                let isFirst = true

                vulnTypes.eachAsync(async (document) => {
                    if (!isFirst) {
                        writeStream.write(',')
                    } else {
                        isFirst = false
                    }
                    writeStream.write(JSON.stringify(document, null, 2))
                    return Promise.resolve()
                })
                .then(() => {
                    writeStream.write(']');
                    writeStream.end();
                })
                .catch((error) => {
                    reject(error);
                });

                writeStream.on('finish', () => {
                    resolve('ok');
                });
            
                writeStream.on('error', (error) => {
                    reject(error);
                });
            })
        }

        try {
            await exportVulnTypesPromise()
            resolve()
        }
        catch (error) {
            reject({error: error, model: 'VulnerabilityType'})
        }
            
    })
}

VulnerabilityTypeSchema.statics.restore = (path, mode = "upsert") => {
    return new Promise(async (resolve, reject) => {
        const fs = require('fs')

        function importVulnTypesPromise () {
            return new Promise((resolve, reject) => {
                const readStream = fs.createReadStream(`${path}/vulnerabilityTypes.json`)
                const JSONStream = require('JSONStream')

                let jsonStream = JSONStream.parse('*')
                readStream.pipe(jsonStream)

                readStream.on('error', (error) => {
                    reject(error)
                })

                jsonStream.on('data', async (document) => {
                    delete document._id
                    VulnerabilityType.findOneAndReplace({name: document.name, locale: document.locale}, document, { upsert: true, new: true })
                    .catch(err => {
                        console.log(err)
                        reject(err)
                    })
                })
                jsonStream.on('end', () => {
                    resolve()
                })
                jsonStream.on('error', (error) => {
                    reject(error)
                })
            })
        }

        try {
            if (mode === "revert") 
                await VulnerabilityType.deleteMany()
            await importVulnTypesPromise()
            resolve()
        }
        catch (error) {
            reject({error: error, model: 'VulnerabilityType'})
        }
    })
}

/*
*** Methods ***
*/

var VulnerabilityType = mongoose.model('VulnerabilityType', VulnerabilityTypeSchema);
module.exports = VulnerabilityType;