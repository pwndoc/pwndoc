var mongoose = require('mongoose');
var _ = require('lodash');

var Schema = mongoose.Schema;

var customField = {
    _id:        false,
    customField:  {type: Schema.Types.ObjectId, ref: 'CustomField'},
    text:       String
}

var VulnerabilityUpdateSchema = new Schema({
    vulnerability:          {type: Schema.Types.ObjectId, ref: 'Vulnerability', required: true},
    creator:                {type: Schema.Types.ObjectId, ref: 'User', required: true},
    cvssv3:                 String,
    cvssScore:              String,
    cvssSeverity:           String,
    priority:               {type: Number, enum: [1,2,3,4]},
    remediationComplexity:  {type: Number, enum: [1,2,3]},
    references:             [String],
    locale:                 String,
    title:                  String,
    vulnType:               String,
    description:            String,
    observation:            String,
    remediation:            String,
    category:               String,
    customFields:           [customField]

}, {timestamps: true});

/*
*** Statics ***
*/

// Get all vulnerabilities
VulnerabilityUpdateSchema.statics.getAll = () => {
    return new Promise((resolve, reject) => {
        var query = VulnerabilityUpdate.find();
        query.exec()
        .then((rows) => {
            resolve(rows);
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Get all updates of vulnerability
VulnerabilityUpdateSchema.statics.getAllByVuln = (vulnId) => {
    return new Promise((resolve, reject) => {
        var query = VulnerabilityUpdate.find({vulnerability: vulnId});
        query.populate('creator', '-_id username');
        query.populate('customFields.customField', 'fieldType label displayVuln displayFinding displayCategory')
        query.exec()
        .then((rows) => {
            resolve(rows);
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Create vulnerability
VulnerabilityUpdateSchema.statics.create = (username, vulnerability) => {
    return new Promise((resolve, reject) => {
        var created = true;
        var User = mongoose.model('User');
        var creator = "";
        var Vulnerability = mongoose.model("Vulnerability");
        var query = User.findOne({username: username});
        query.exec()
        .then((row) => {
            if (row) {
                creator = row._id;
                var query = Vulnerability.findOne({'details.title': vulnerability.title});
                return query.exec();
            }
            else
                throw({fn: 'NotFound', message: 'User not found'});
        })
        .then((row) => {
            if (row) {
                if (row.status === 1)
                    throw({fn: 'Forbidden', message: 'Vulnerability not approved yet'})
                else {
                    // Check if there are any changes from the original vulnerability
                    var detail = row.details.find(d => d.locale === vulnerability.locale)
                    if (detail !== 'undefined' &&
                        (row.cvssv3 || "").includes(vulnerability.cvssv3) &&
                        vulnerability.priority === (row.priority || null) &&
                        vulnerability.remediationComplexity === (row.remediationComplexity || null) &&
                        _.isEqual(vulnerability.references, (row.references || [])) &&
                        vulnerability.category === (row.category || null) &&
                        vulnerability.vulnType === (detail.vulnType || null) &&
                        vulnerability.description === (detail.description || null) &&
                        vulnerability.observation === (detail.observation || null) &&
                        vulnerability.remediation === (detail.remediation || null) &&
                        _.isEqual(vulnerability.customFields, (detail.customFields || []))
                        ) {
                            throw({fn: 'BadParameters', message: 'No changes from the original vulnerability'})
                    }
                    vulnerability.vulnerability = row._id;
                    vulnerability.creator = creator;
                    var query = new VulnerabilityUpdate(vulnerability);
                    created = false;
                    return query.save();
                }
            }
            else {
                var vuln = {}
                vuln.cvssv3 = vulnerability.cvssv3 || null;
                vuln.cvssScore = vulnerability.cvssScore || null;
                vuln.cvssSeverity = vulnerability.cvssSeverity || null;
                vuln.priority = vulnerability.priority || null;
                vuln.remediationComplexity = vulnerability.remediationComplexity || null;
                vuln.references = vulnerability.references || null;
                vuln.category = vulnerability.category || null;
                var details = {};
                details.locale = vulnerability.locale || null;
                details.title = vulnerability.title || null;
                details.vulnType = vulnerability.vulnType || null;
                details.description = vulnerability.description || null;
                details.observation = vulnerability.observation || null;
                details.remediation = vulnerability.remediation || null;
                details.customFields = vulnerability.customFields || [];
                vuln.details = [details];
                var query = new Vulnerability(vuln);
                return query.save();
            }
        })
        .then((row) => {
            if (created)
                resolve("Finding created as new Vulnerability");
            else {
                var query = Vulnerability.findOneAndUpdate({'details.title': vulnerability.title}, {status: 2});
                return query.exec();
            }
        })
        .then((row) => {
            resolve("Update proposed for existing vulnerability");
        })
        .catch((err) => {
            reject(err);
        })
    })
}

// Delete vulnerability updates based on vulnId reference
VulnerabilityUpdateSchema.statics.deleteAllByVuln = (vulnId) => {
    return new Promise((resolve, reject) => {
        var query = VulnerabilityUpdate.deleteMany({vulnerability: vulnId});
        query.exec()
        .then((row) => {
            if (row.deletedCount > 0)
                resolve('Vulnerability Updates deleted successfully');
            else
                reject({fn: 'BadParameters', message: 'Vulnerability Updates not found'});
        })
        .catch((err) => {
            reject(err);
        })
    });
}

/*
*** Methods ***
*/

var VulnerabilityUpdate = mongoose.model('VulnerabilityUpdate', VulnerabilityUpdateSchema);
module.exports = VulnerabilityUpdate;