var mongoose = require('mongoose');
var Schema = mongoose.Schema;

var customField = {
    _id:            false,
    customField:  {type: Schema.Types.ObjectId, ref: 'CustomField'},
    text:           Schema.Types.Mixed
}

var VulnerabilityDetails = {
    _id:            false,
    locale:         String,
    // language:       String,
    title:          {type: String, unique: true, sparse: true},
    vulnType:       String,
    description:    String,
    observation:    String,
    remediation:    String,
    references:     [String],
    customFields:   [customField]
}

var VulnerabilitySchema = new Schema({
    cvssv3:                 String,
    cvssv4:                 String,
    priority:               {type: Number, enum: [1,2,3,4]},
    remediationComplexity:  {type: Number, enum: [1,2,3]},
    details:                [VulnerabilityDetails],
    status:                 {type: Number, enum: [0,1,2], default: 1}, // 0: validated, 1: created, 2: updated,
    category:               String,
    creator:                {type: Schema.Types.ObjectId, ref: 'User'}


}, {timestamps: true});

/*
*** Statics ***
*/

// Get all vulnerabilities
VulnerabilitySchema.statics.getAll = () => {
    return new Promise((resolve, reject) => {
        var query = Vulnerability.find();
        query.populate('creator', '-_id username');
        query.exec()
        .then((rows) => {
            resolve(rows);
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Get all vulnerabilities for download
VulnerabilitySchema.statics.export = () => {
    return new Promise((resolve, reject) => {
        var query = Vulnerability.find();
        query.select('details cvssv3 cvssv4 priority remediationComplexity references category -_id')
        query.exec()
        .then((rows) => {
            resolve(rows);
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Create vulnerability
VulnerabilitySchema.statics.create = (vulnerabilities) => {
    return new Promise((resolve, reject) => {
        Vulnerability.insertMany(vulnerabilities, {ordered: false})
        .then((rows) => {
            resolve({created: rows.length, duplicates: 0});
        })
        .catch((err) => {
            if (err.code === 11000) {
                if (err.result.insertedCount === 0)
                    reject({fn: 'BadParameters', message: 'Vulnerability title already exists'});
                else {
                    var errorMessages = [] 
                    err.writeErrors.forEach(e => errorMessages.push(e.errmsg || "no errmsg"))
                    resolve({created: err.result.insertedCount, duplicates: errorMessages});
                }
            }
            else
                reject(err);
        })
    })
}

// Update vulnerability
VulnerabilitySchema.statics.update = (vulnerabilityId, vulnerability) => {
    return new Promise((resolve, reject) => {
        var VulnerabilityUpdate = mongoose.model("VulnerabilityUpdate");
        var query = Vulnerability.findByIdAndUpdate(vulnerabilityId, vulnerability);
        query.exec()
        .then((row) => {
            if (!row)
                reject({fn: 'NotFound', message: 'Vulnerability not found'});
            else {
                var query = VulnerabilityUpdate.deleteMany({vulnerability: vulnerabilityId});
                return query.exec();
            }
        })
        .then((row) => {
            resolve('Vulnerability updated successfully');    
        })
        .catch((err) => {
            if (err.code === 11000)
                reject({fn: 'BadParameters', message: 'Vulnerability title already exists'});
            else
                reject(err);
        })
    });
}

// Delete all vulnerabilities
VulnerabilitySchema.statics.deleteAll = () => {
    return new Promise((resolve, reject) => {
        var query = Vulnerability.deleteMany();
        query.exec()
        .then(() => {
            resolve('All vulnerabilities deleted successfully');
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Delete vulnerability
VulnerabilitySchema.statics.delete = (vulnerabilityId) => {
    return new Promise((resolve, reject) => {
        var query = Vulnerability.findByIdAndDelete(vulnerabilityId);
        query.exec()
        .then((rows) => {
            if (rows)
                resolve(rows);
            else
                reject({fn: 'NotFound', message: 'Vulnerability not found'});
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Get vulnerabilities by language
VulnerabilitySchema.statics.getAllByLanguage = (locale) => {
    return new Promise((resolve, reject) => {
        var query = Vulnerability.find({'details.locale': locale})
        query.select('details cvssv3 cvssv4 priority remediationComplexity category')
        query.exec()
        .then((rows) => {
            if (rows) {
                var result = [];
                rows.forEach(row => {
                    row.details.forEach(detail => {
                        if (detail.locale === locale && detail.title){
                            var temp = {};
                            temp.cvssv3 = row.cvssv3;
                            temp.cvssv4 = row.cvssv4;
                            temp.priority = row.priority;
                            temp.remediationComplexity = row.remediationComplexity;
                            temp.category = row.category;
                            temp.detail= detail;
                            temp._id = row._id;
                            result.push(temp);
                        }
                    })
                })
                resolve(result);
            }
            else
                reject({fn: 'NotFound', message: 'Locale with existing title not found'});
        })
        .catch((err) => {
            reject(err);
        })
    });
}

VulnerabilitySchema.statics.Merge = (vulnIdPrime, vulnIdMerge, locale) => {
    return new Promise((resolve, reject) => {
        var mergeDetail = null;
        var mergeVuln = null;
        var primeVuln = null;
        var query = Vulnerability.findById(vulnIdMerge);
        query.exec()
        .then((row) => {
            if (!row)
                reject({fn: 'NotFound', message: 'Vulnerability not found'});
            else {
                mergeVuln = row;
                mergeDetail = row.details.find(d => d.locale === locale);
                var query = Vulnerability.findById(vulnIdPrime);
                return query.exec();
            }
        })
        .then((row) => {
            if (!row)
                reject({fn: 'NotFound', message: 'Vulnerability not found'});
            else {
                if (row.details.findIndex(d => (d.locale === locale && d.title)) !== -1)
                    reject({fn: 'BadParameters', message: 'Language already exists in this vulnerability'});
                else {
                    primeVuln = row;
                    var removeIndex = mergeVuln.details.map(d => d.title).indexOf(mergeDetail.title);
                    mergeVuln.details.splice(removeIndex, 1)
                    if (mergeVuln.details.length === 0)
                        return Vulnerability.findByIdAndDelete(mergeVuln._id);
                    else
                        return mergeVuln.save();
                }
            }
        })
        .then(() => {
            var detail = {};
            detail.locale = mergeDetail.locale;
            detail.title = mergeDetail.title;
            if (mergeDetail.vulnType) detail.vulnType = mergeDetail.vulnType;
            if (mergeDetail.description) detail.description = mergeDetail.description;
            if (mergeDetail.observation) detail.observation = mergeDetail.observation;
            if (mergeDetail.remediation) detail.remediation = mergeDetail.remediation;
            if (mergeDetail.customFields) detail.customFields = mergeDetail.customFields;
            primeVuln.details.push(detail);
            return primeVuln.save();
        })
        .then(() => {
            resolve('Vulnerability merge successfull');
        })
        .catch((err) => {
            reject(err);
        })
    });
}

VulnerabilitySchema.statics.getVulnsImages = (vulnsIds = []) => {
    return new Promise((resolve, reject) => {
        var imgRegex = new RegExp(/img src=["']([0-9a-f]{24})["']/)
        var matchFilter = {
            $or: [
                {"details.description": {$regex: imgRegex}},
                {"details.observation": {$regex: imgRegex}},
                {"details.remediation": {$regex: imgRegex}},
                {"details.customFields.text": {$regex: imgRegex}}
            ]
        }
        if (vulnsIds.length > 0)
            matchFilter['_id'] = {$in: vulnsIds.map(e => new mongoose.Types.ObjectId(e))}
        var query = Vulnerability.aggregate([{$match: matchFilter}])
        query.unwind('$details')
        query.unwind({path: '$details.customFields', preserveNullAndEmptyArrays: true})
        query.addFields({
            imageFields: {
            $concat: [
                {$cond: [{$eq: [{$type: "$details.description"}, "string"]}, "$details.description", ""]},
                {$cond: [{$eq: [{$type: "$details.observation"}, "string"]}, "$details.observation", ""]},
                {$cond: [{$eq: [{$type: "$details.remediation"}, "string"]}, "$details.remediation", ""]},
                {$cond: [{$eq: [{$type: "$details.customFields.text"}, "string"]}, "$details.customFields.text", ""]},
            ],
            },
        })
        query.project({
            _id: 0,
            name: "$name",
            images: {
                $regexFindAll: {
                    input: "$imageFields",
                    regex: imgRegex,
                },
            },
        })
        query.exec()
        .then(row => {
            if (!row)
                throw ({ fn: 'NotFound', message: 'Vulnerabilities not found' })
            else {
                var images = []
                row.forEach(e => e.images.forEach(img => images.push(img.captures[0])))
                var imagesUniq = [...new Set(images)]
                resolve(imagesUniq);
            }
        })
        .catch((err) => {
            reject(err)
        })
    })
}

VulnerabilitySchema.statics.backup = (path, vulnsIds = []) => {
    return new Promise(async (resolve, reject) => {
        const fs = require('fs')

        function exportVulnsPromise() { 
            return new Promise((resolve, reject) => {
                let filters = {}

                const writeStream = fs.createWriteStream(`${path}/vulnerabilities.json`)

                writeStream.write('[')

                if (vulnsIds.length > 0)
                    filters = {'_id': {$in: vulnsIds}}
                let vulns = Vulnerability.find(filters).cursor()
                let isFirst = true

                vulns.eachAsync(async (document) => {
                    if (!isFirst) {
                        writeStream.write(',')
                    } else {
                        isFirst = false
                    }
                    writeStream.write(JSON.stringify(document, null, 2))
                    return Promise.resolve()
                })
                .then(() => {
                    writeStream.write(']');
                    writeStream.end();
                })
                .catch((error) => {
                    reject(error);
                });

                writeStream.on('finish', () => {
                    resolve('ok');
                });
            
                writeStream.on('error', (error) => {
                    reject(error);
                });
            })
        }

        function exportImagesPromise() { 
            return new Promise(async (resolve, reject) => {
                const Image = mongoose.model("Image");
                const writeStream = fs.createWriteStream(`${path}/vulnerabilities-images.json`)
                writeStream.write('[')

                let vulnsImages = await Vulnerability.getVulnsImages(vulnsIds)
                let images = Image.find({'_id': {'$in': vulnsImages}}).cursor()

                let isFirst = true
                images.eachAsync(async (document) => {
                    if (!isFirst) {
                        writeStream.write(',')
                    } else {
                        isFirst = false
                    }
                    writeStream.write(JSON.stringify(document, null, 2))
                    return Promise.resolve()
                })
                .then(() => {
                    writeStream.write(']');
                    writeStream.end();
                })
                .catch((error) => {
                    reject(error);
                });

                writeStream.on('finish', () => {
                    resolve('ok');
                });
            
                writeStream.on('error', (error) => {
                    reject(error);
                });
            })
        }

        try {
            await Promise.all([exportVulnsPromise(), exportImagesPromise()])
            resolve()
        }
        catch (error) {
            reject({error: error, model: 'Vulnerability'})
        }
    })
}

VulnerabilitySchema.statics.restore = (path, mode = "upsert") => {
    return new Promise(async (resolve, reject) => {
        const fs = require('fs')

        function importVulnsPromise() {
            let documents = []

            return new Promise((resolve, reject) => {
                const readStream = fs.createReadStream(`${path}/vulnerabilities.json`)
                const JSONStream = require('JSONStream')

                let jsonStream = JSONStream.parse('*')
                readStream.pipe(jsonStream)

                readStream.on('error', (error) => {
                    reject(error)
                })

                jsonStream.on('data', (document) => {
                    documents.push(document)
                    if (documents.length === 100) {
                        Vulnerability.bulkWrite(documents.map(document => {
                            return {
                                replaceOne: {
                                    filter: {details: document.details},
                                    replacement: document,
                                    upsert: true
                                }
                            }
                        }))
                        .catch(err => {
                            reject(err)
                        })
                        documents = []
                    }
                })
                jsonStream.on('end', () => {
                    if (documents.length > 0) {
                        Vulnerability.bulkWrite(documents.map(document => {
                            return {
                                replaceOne: {
                                    filter: {details: document.details},
                                    replacement: document,
                                    upsert: true
                                }
                            }
                        }))
                        .then(() => {
                            resolve()
                        })
                        .catch(err => {
                            reject(err)
                        })
                    }
                    else
                        resolve()
                })
                jsonStream.on('error', (error) => {
                    reject(error)
                })
            })
        }

        function importImagesPromise() {
            let documents = []

            return new Promise((resolve, reject) => {
                const Image = mongoose.model("Image");
                const readStream = fs.createReadStream(`${path}/vulnerabilities-images.json`)
                const JSONStream = require('JSONStream')

                let jsonStream = JSONStream.parse('*')
                readStream.pipe(jsonStream)

                readStream.on('error', (error) => {
                    reject(error)
                })

                jsonStream.on('data', (document) => {
                    documents.push(document)
                    if (documents.length === 100) {
                        Image.bulkWrite(documents.map(document => {
                            return {
                                replaceOne: {
                                    filter: {_id: document._id},
                                    replacement: document,
                                    upsert: true
                                }
                            }
                        }))
                        .catch(err => {
                            reject(err)
                        })
                        documents = []
                    }
                })
                jsonStream.on('end', () => {
                    if (documents.length > 0) {
                        Image.bulkWrite(documents.map(document => {
                            return {
                                replaceOne: {
                                    filter: {_id: document._id},
                                    replacement: document,
                                    upsert: true
                                }
                            }
                        }))
                        .then(() => {
                            resolve()
                        })
                        .catch(err => {
                            reject(err)
                        })
                    }
                    else
                        resolve()
                })
                jsonStream.on('error', (error) => {
                    reject(error)
                })
            })
        }

        try {
            if (mode == "revert")
                await Vulnerability.deleteMany()
            await Promise.all([importVulnsPromise(), importImagesPromise()])
            resolve()
        }
        catch (error) {
            reject({error: error, model: 'Vulnerability'})
        }
    })
}

/*
*** Methods ***
*/

var Vulnerability = mongoose.model('Vulnerability', VulnerabilitySchema);
module.exports = Vulnerability;